<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android-主要的热修复方案原理分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/29/Android-主要的热修复方案原理分析/" class="article-date">
  <time datetime="2016-09-29T07:23:43.000Z" itemprop="datePublished">2016-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/29/Android-主要的热修复方案原理分析/">Android 主要的热修复方案原理分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目前较为成熟的热修复框架主要有AndFix、Nuwa以及微信的热更新思想。现在将其主要思想总结如下：</p>
<h1 id="AndFix"><a href="#AndFix" class="headerlink" title="AndFix"></a>AndFix</h1><p><a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix</a>是支付宝开源的一套热修复框架，使用简单，成功率高，基本满足大多数的bug修复场景。引入到项目中非常方便，主要分两步：</p>
<ul>
<li><p>代码整合</p>
<ul>
<li>build.gradle添加依赖 compile ‘com.alipay.euler:andfix:0.4.0@aar’</li>
<li><p>Application.onCreate()方法中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PatchManager patchManager = new PatchManager(this);</div><div class="line">patchManager.init(appversion);//current version</div><div class="line">patchManager.loadPatch();</div></pre></td></tr></table></figure>
<p>然后和后端协商一个补丁包下载服务器，在每次下载更新包到本地后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">patchManager.addPatch(path);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>打补丁<br>AndFix提供了一个打补丁包的工具，可以<a href="https://raw.githubusercontent.com/alibaba/AndFix/master/tools/apkpatch-1.0.3.zip" target="_blank" rel="external">去这里</a>下载，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apkpatch -f &lt;new&gt; -t &lt;old&gt; -o &lt;output&gt; -k &lt;keystore&gt; -p &lt;***&gt; -a &lt;alias&gt; -e &lt;***&gt;</div><div class="line"> -a,--alias &lt;alias&gt;     keystore entry alias.</div><div class="line"> -e,--epassword &lt;***&gt;   keystore entry password.</div><div class="line"> -f,--from &lt;loc&gt;        new Apk file path.</div><div class="line"> -k,--keystore &lt;loc&gt;    keystore path.</div><div class="line"> -n,--name &lt;name&gt;       patch name.</div><div class="line"> -o,--out &lt;dir&gt;         output dir.</div><div class="line"> -p,--kpassword &lt;***&gt;   keystore password.</div><div class="line"> -t,--to &lt;loc&gt;          old Apk file path.</div></pre></td></tr></table></figure>
</li>
</ul>
<p>AndFix的思想是直接更改修复的方法，具体我们可以看源码。先从PatchManager的init和load方法入手，这两个方法实现了补丁包的加载并最终调用了AndFixManager的fix方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (Patch patch : mPatchs) &#123;</div><div class="line">			patchNames = patch.getPatchNames();</div><div class="line">			if (patchNames.contains(patchName)) &#123;</div><div class="line">				classes = patch.getClasses(patchName);</div><div class="line">				mAndFixManager.fix(patch.getFile(), classLoader, classes);</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>fix函数需要传入三个参数：patch文件、classloader以及需要fix的class列表。fix函数代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * fix</div><div class="line"> * </div><div class="line"> * @param file</div><div class="line"> *            patch file</div><div class="line"> * @param classLoader</div><div class="line"> *            classloader of class that will be fixed</div><div class="line"> * @param classes</div><div class="line"> *            classes will be fixed</div><div class="line"> */</div><div class="line">public synchronized void fix(File file, ClassLoader classLoader,</div><div class="line">		List&lt;String&gt; classes) &#123;</div><div class="line">	</div><div class="line">	    .......省略........</div><div class="line">           //load dex文件</div><div class="line">		final DexFile dexFile = DexFile.loadDex(file.getAbsolutePath(),</div><div class="line">				optfile.getAbsolutePath(), Context.MODE_PRIVATE);</div><div class="line"></div><div class="line">		if (saveFingerprint) &#123;</div><div class="line">			mSecurityChecker.saveOptSig(optfile);</div><div class="line">		&#125;</div><div class="line">          // 定义自己的classloader</div><div class="line">		ClassLoader patchClassLoader = new ClassLoader(classLoader) &#123;</div><div class="line">			@Override</div><div class="line">			protected Class&lt;?&gt; findClass(String className)</div><div class="line">					throws ClassNotFoundException &#123;</div><div class="line">				Class&lt;?&gt; clazz = dexFile.loadClass(className, this);</div><div class="line">				if (clazz == null</div><div class="line">						&amp;&amp; className.startsWith(&quot;com.alipay.euler.andfix&quot;)) &#123;</div><div class="line">					return Class.forName(className);// annotation’s class</div><div class="line">													// not found</div><div class="line">				&#125;</div><div class="line">				if (clazz == null) &#123;</div><div class="line">					throw new ClassNotFoundException(className);</div><div class="line">				&#125;</div><div class="line">				return clazz;</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">		Enumeration&lt;String&gt; entrys = dexFile.entries();</div><div class="line">		Class&lt;?&gt; clazz = null;</div><div class="line">		while (entrys.hasMoreElements()) &#123;</div><div class="line">			String entry = entrys.nextElement();</div><div class="line">			if (classes != null &amp;&amp; !classes.contains(entry)) &#123;</div><div class="line">				continue;// skip, not need fix</div><div class="line">			&#125;</div><div class="line">			clazz = dexFile.loadClass(entry, patchClassLoader);</div><div class="line">			if (clazz != null) &#123;</div><div class="line">				fixClass(clazz, classLoader);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125; catch (IOException e) &#123;</div><div class="line">		Log.e(TAG, &quot;pacth&quot;, e);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法的作用是load dex文件中的类，并依次修复，这个函数中有两处疑问：</p>
<ul>
<li>classes参数设计有何深意，因为我理解的patch包里面难道不都是需要修复的类吗，还会把没有修改的类打进去吗？</li>
<li>自定义了一个classloader,针对”com.alipay.euler.andfix”做了特殊处理，不知道怎么才会有这种场景。<br>针对这两个问题我特意咨询了AndFix的作者黎三平大神，大神给我的答复是：1. 这个设计有两个原因：<br>a） 新增类<br>b）早期patch工具打出的补丁包不是很准确<br>2.AndFix的一个注解，它的类加载会走到这来的。<br>大神的话还是不是很明白，大家如果看到了这块代码请帮我解释一下。</li>
</ul>
<p>fix函数中遍历dex的类，并过滤掉不需要修复的类后调用fixclass函数，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private void fixClass(Class&lt;?&gt; clazz, ClassLoader classLoader) &#123;</div><div class="line">	Method[] methods = clazz.getDeclaredMethods();</div><div class="line">	MethodReplace methodReplace;</div><div class="line">	String clz;</div><div class="line">	String meth;</div><div class="line">	for (Method method : methods) &#123;</div><div class="line">		methodReplace = method.getAnnotation(MethodReplace.class);</div><div class="line">		if (methodReplace == null)</div><div class="line">			continue;</div><div class="line">		clz = methodReplace.clazz();</div><div class="line">		meth = methodReplace.method();</div><div class="line">		if (!isEmpty(clz) &amp;&amp; !isEmpty(meth)) &#123;</div><div class="line">			replaceMethod(classLoader, clz, meth, method);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 代码很简洁，意思也很明了，就是找到这个类中需要修复的函数然后调用replaceMethod方法。替换方法在java层是无法做到的，所以这个函数最终还是调用了native的替换函数的方法，实质就是更改了类中方法所指向的地址，所以java不能做到。</p>
<p>jin的目录结构如下：<br><img src="http://upload-images.jianshu.io/upload_images/2023045-706b8167f9dc514a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AndFix Jni结构.png"></p>
<p>AndFix做了dalvik、art以及各平台的适配，核心是方法的替换，我们来看其中一个方法替换的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">extern void __attribute__ ((visibility (&quot;hidden&quot;))) dalvik_replaceMethod(</div><div class="line">		JNIEnv* env, jobject src, jobject dest) &#123;</div><div class="line">	jobject clazz = env-&gt;CallObjectMethod(dest, jClassMethod);</div><div class="line">	ClassObject* clz = (ClassObject*) dvmDecodeIndirectRef_fnPtr(</div><div class="line">			dvmThreadSelf_fnPtr(), clazz);</div><div class="line">	clz-&gt;status = CLASS_INITIALIZED;</div><div class="line"></div><div class="line">	Method* meth = (Method*) env-&gt;FromReflectedMethod(src);</div><div class="line">	Method* target = (Method*) env-&gt;FromReflectedMethod(dest);</div><div class="line">	LOGD(&quot;dalvikMethod: %s&quot;, meth-&gt;name);</div><div class="line"></div><div class="line">	meth-&gt;clazz = target-&gt;clazz;</div><div class="line">	meth-&gt;accessFlags |= ACC_PUBLIC;</div><div class="line">	meth-&gt;methodIndex = target-&gt;methodIndex;</div><div class="line">	meth-&gt;jniArgInfo = target-&gt;jniArgInfo;</div><div class="line">	meth-&gt;registersSize = target-&gt;registersSize;</div><div class="line">	meth-&gt;outsSize = target-&gt;outsSize;</div><div class="line">	meth-&gt;insSize = target-&gt;insSize;</div><div class="line"></div><div class="line">	meth-&gt;prototype = target-&gt;prototype;</div><div class="line">	meth-&gt;insns = target-&gt;insns;</div><div class="line">	meth-&gt;nativeFunc = target-&gt;nativeFunc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>含义估计大家都明白，就是把方法的各个属性值替换，实际去写确实还是很有难度。</p>
<p>至此我把AndFix代码的主要流程梳理了一遍，其中还有很多没有get到的点，思想基本清楚了，AndFix主要采用替换方法的方式进行热修复，好处是立即生效且补丁包较小，但是只能基于方法修复，而且对平台的兼容性不佳，但不失为一个伟大的想法，也是热修复最早开源的修复方案，向我的黎三平大神说声感谢！</p>
<h1 id="Nuwa"><a href="#Nuwa" class="headerlink" title="Nuwa"></a>Nuwa</h1><p>AndFix的思路很简单，直接在native层替代方法，有没有更简单的呢，有，<a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">Nuwa</a>！他的想法就更自然一些，直接替换类，或者废弃掉有bug的类，怎么做到的呢，核心就在于java.lang.ClassLoader.java这个类的loadClass方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123;</div><div class="line">       Class&lt;?&gt; clazz = findLoadedClass(className);</div><div class="line"></div><div class="line">       if (clazz == null) &#123;</div><div class="line">           ClassNotFoundException suppressed = null;</div><div class="line">           try &#123;</div><div class="line">               clazz = parent.loadClass(className, false);</div><div class="line">           &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">               suppressed = e;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           if (clazz == null) &#123;</div><div class="line">               try &#123;</div><div class="line">                   clazz = findClass(className);</div><div class="line">               &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                   e.addSuppressed(suppressed);</div><div class="line">                   throw e;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return clazz;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>同名的类加载一次就不再加载了，是不是想到什么了，哈哈，对，就是把你要修复的类提前加载就ok了，那么有bug的类便不再加载进来，实现起来也非常简单，三行代码搞定，我们看Nuwa的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static void injectDexAtFirst(String dexPath, String defaultDexOptPath) throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;</div><div class="line">    //新建补丁包的dexclassloader</div><div class="line">    DexClassLoader dexClassLoader = new DexClassLoader(dexPath, defaultDexOptPath, dexPath, getPathClassLoader());</div><div class="line">    //获取原dex加载列表 </div><div class="line">    Object baseDexElements = getDexElements(getPathList(getPathClassLoader()));</div><div class="line">    // 新建补丁包dex加载列表</div><div class="line">    Object newDexElements = getDexElements(getPathList(dexClassLoader));</div><div class="line">    //补丁包插在最前连接成新的dex加载列表</div><div class="line">    Object allDexElements = combineArray(newDexElements, baseDexElements);</div><div class="line">    Object pathList = getPathList(getPathClassLoader());</div><div class="line">    //利用发射修改dalvik.system.BaseDexClassLoader类的pathList中的dexElements属性</div><div class="line">    ReflectionUtils.setField(pathList, pathList.getClass(), &quot;dexElements&quot;, allDexElements);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就这么几行代码就实现了替换类的热修复，没有native的操作，思路清晰，含义明确。当然这里面还有一个坑就是类加载的时候会有一个标记一个类和另外在同一个dex中的标记，所以打出补丁包之后会报 “两个类所在的dex不在一起” 的错误，这个也好办，打出一个单独的dex，里面只有一个类，让每个类都引用这个类，这样就使得每个类的标记都是false。Nuwa实现了这个插入引用单独类的插件，对使用者非常友好。</p>
<p>Nuwa能自由的修改和添加类，功能更加强大，不过这里面隐含了一个缺陷就是hook  classloader的dexElements必须在所有类没有加载之前进行，所以一般放在application的oncreate方法中，这样就导致了每次发布补丁必须重启app才能生效。</p>
<h1 id="微信的热修复方案"><a href="#微信的热修复方案" class="headerlink" title="微信的热修复方案"></a>微信的热修复方案</h1><p>其实技术方案的迭代也是思绪不断延伸的过程，看过Nuwa的热修复方案之后，是不是会想到有没有更简单更优雅的方式，有！其实很容易想到，我们在客户端实现补丁包的逻辑是什么呢，无非是比较两个dex中类文件发生更改的类提取出来，打成新的补丁dex，那这个过程能不能在客户端逆向操作一次呢，直接将差分包和原dex进行融合，形成新的dex，这样代码就不用做任何修改了，答案是肯定的。微信在一篇博客中阐述了自己热修复方案的主要思路(<a href="http://www.tuicool.com/articles/uym2QrU" target="_blank" rel="external">微信Android热补丁实践演进之路</a>)。没有具体实现，主要可能是文件权限的一些坑，但是像微信这样的app架构中，肯定是做了精准的分包处理，自己管理dex的加载策略，所以实现起来应该非常顺利。<br>微信在文中也坦言做热修复起源于15年6月，相对较晚，也可以综合比较之后设计出适合自己的方案。</p>
<p>以上是目前比较成熟的几个热修复方案，只是整理了主要思想，还有很多黑科技没有get到，希望对大家能有所帮助。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/29/Android-主要的热修复方案原理分析/" data-id="cito0mhj700009ctol9bo0bx4" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RecyclerView高端定制三部曲" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/29/RecyclerView高端定制三部曲/" class="article-date">
  <time datetime="2016-09-29T07:22:18.000Z" itemprop="datePublished">2016-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/29/RecyclerView高端定制三部曲/">RecyclerView高端定制三部曲</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RecyclerView随V7拓展包发布以来，因其高效和使用便利，基本取代了listview和gridview，成为了使用频率最高的控件之一。默认的设置基本能满足大部分场景，如果需要更好的体验，需要自定义以下三个部分的内容：</p>
<ul>
<li><h6 id="Animator"><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h6></li>
<li><h6 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h6></li>
<li><h6 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h6></li>
</ul>
<h1 id="自定义Animator"><a href="#自定义Animator" class="headerlink" title="自定义Animator"></a>自定义Animator</h1><p>自定义Animator可以实现各种绚丽的动画效果，RecyclerView动画相关的类主要有三个：</p>
<ul>
<li><h6 id="RecyclerView-ItemAnimator"><a href="#RecyclerView-ItemAnimator" class="headerlink" title="RecyclerView.ItemAnimator"></a>RecyclerView.ItemAnimator</h6></li>
<li><h6 id="SimpleItemAnimator"><a href="#SimpleItemAnimator" class="headerlink" title="SimpleItemAnimator"></a>SimpleItemAnimator</h6></li>
<li><h6 id="DefaultItemAnimator"><a href="#DefaultItemAnimator" class="headerlink" title="DefaultItemAnimator"></a>DefaultItemAnimator</h6></li>
</ul>
<p>RecyclerView.ItemAnimator是自定义RecyclerView动画效果的核心类，当继承一个ItemAnimator时，有如下几个方法需要被实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//当一个ViewHolder从RecyclerView里面消失时调用,不一定是移除，也有可能是move操作</div><div class="line">@Override  </div><div class="line">    public boolean animateDisappearance(RecyclerView.ViewHolder viewHolder, ItemHolderInfo preLayoutInfo, ItemHolderInfo postLayoutInfo) &#123;  </div><div class="line">        return false;  </div><div class="line">    &#125;  </div><div class="line">  //当一个ViewHolder从RecyclerView里面显示时调用,不一定是新增，也有可能是move操作</div><div class="line">    @Override  </div><div class="line">    public boolean animateAppearance(RecyclerView.ViewHolder viewHolder, ItemHolderInfo preLayoutInfo, ItemHolderInfo postLayoutInfo) &#123;  </div><div class="line">        return false;  </div><div class="line">    &#125;  </div><div class="line">  //没有调用notify而引起布局的改变，比如滑动</div><div class="line">    @Override  </div><div class="line">    public boolean animatePersistence(RecyclerView.ViewHolder viewHolder, ItemHolderInfo preLayoutInfo, ItemHolderInfo postLayoutInfo) &#123;  </div><div class="line">        return false;  </div><div class="line">    &#125;  </div><div class="line">  //item发生改变的时候调用</div><div class="line">    @Override  </div><div class="line">    public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, ItemHolderInfo preLayoutInfo, ItemHolderInfo postLayoutInfo) &#123;  </div><div class="line">        return false;  </div><div class="line">    &#125;  </div><div class="line">  //统筹RecyclerView中所有的动画，统一启动执行,一般的思路是在前面几个函数调用中放入一个动画列表，在这个函数中统一执行</div><div class="line">    @Override  </div><div class="line">    public void runPendingAnimations() &#123;  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">  //结束某一个item的动画</div><div class="line">    @Override  </div><div class="line">    public void endAnimation(RecyclerView.ViewHolder item) &#123;  </div><div class="line">    &#125;  </div><div class="line">  //结束所有的动画</div><div class="line">    @Override  </div><div class="line">    public void endAnimations() &#123; </div><div class="line">    &#125;  </div><div class="line">  //动画是否执行过程中</div><div class="line">    @Override  </div><div class="line">    public boolean isRunning() &#123;  </div><div class="line">        return false;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SimpleItemAnimator对RecyclerView.ItemAnimator实现了简单的封装，将基本的ItemAnimator不同场景拆分成我们熟悉的四种场景：add、remove、move、change。所以我们如果实现自定义的动画，继承自SimpleItemAnimator会更容易实现，这也是较为普遍的做法。</p>
<p>DefaultItemAnimator是RecyclerView默认的动画效果，只有一个fadein和fadeout的渐变动画，开始看代码的时候一直有一个疑问，默认的动画效果明明是一个先展开然后插入的动画啊，哪里是渐变的效果。对比了各种动画效果之后发现，这里实现的动画效果只是针对item出现或者消失时的动画，位置展开是RecylerView固定的效果，具体代码没有去源码中跟踪，调用notifyItemInserted函数刷新界面时，先执行对应位置的展开再执行item的动画效果，我们自定义动画就是实现这个item出现的方式，位置展开和收缩是固定的。V7拓展包23.0版本DefaultItemAnimator继承自RecyclerView.ItemAnimator，23.1版本就直接继承自SimpleItemAnimator。</p>
<p>我们参照DefaultItemAnimator的方式实现我们自定义的动画效果。其中最主要的删除和新增实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">private void animateRemoveImpl(final RecyclerView.ViewHolder holder) &#123;</div><div class="line">    final View view = holder.itemView;</div><div class="line">    final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);</div><div class="line">    mRemoveAnimations.add(holder);</div><div class="line">    animation.setDuration(getRemoveDuration())</div><div class="line">            .alpha(0).setListener(new VpaListenerAdapter() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationStart(View view) &#123;</div><div class="line">            dispatchRemoveStarting(holder);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onAnimationEnd(View view) &#123;</div><div class="line">            animation.setListener(null);</div><div class="line">            ViewCompat.setAlpha(view, 1);</div><div class="line">            dispatchRemoveFinished(holder);</div><div class="line">            mRemoveAnimations.remove(holder);</div><div class="line">            dispatchFinishedWhenDone();</div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void animateAddImpl(final RecyclerView.ViewHolder holder) &#123;</div><div class="line">    final View view = holder.itemView;</div><div class="line">    final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);</div><div class="line">    mAddAnimations.add(holder);</div><div class="line">    animation.alpha(1).setDuration(getAddDuration()).</div><div class="line">            setListener(new VpaListenerAdapter() &#123;</div><div class="line">                @Override</div><div class="line">                public void onAnimationStart(View view) &#123;</div><div class="line">                    dispatchAddStarting(holder);</div><div class="line">                &#125;</div><div class="line">                @Override</div><div class="line">                public void onAnimationCancel(View view) &#123;</div><div class="line">                    ViewCompat.setAlpha(view, 1);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onAnimationEnd(View view) &#123;</div><div class="line">                    animation.setListener(null);</div><div class="line">                    dispatchAddFinished(holder);</div><div class="line">                    mAddAnimations.remove(holder);</div><div class="line">                    dispatchFinishedWhenDone();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中写死了animation的效果，而又无法重载，我们将DefaultItemAnimator的代码完全拷出，实现一个可配置动画的BaseItemAnimator类。主要替换的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">private void animateRemoveImpl(final RecyclerView.ViewHolder holder) &#123;</div><div class="line">    mRemoveAnimations.add(holder);</div><div class="line">    final ViewPropertyAnimatorCompat animation = getRemoveAnimator(holder);</div><div class="line">    animation.setDuration(getRemoveDuration()).setListener(new VpaListenerAdapter() &#123;</div><div class="line">                @Override</div><div class="line">                public void onAnimationStart(View view) &#123;</div><div class="line">                    dispatchRemoveStarting(holder);</div><div class="line">                &#125;</div><div class="line">                @Override</div><div class="line">                public void onAnimationEnd(View view) &#123;</div><div class="line">                    animation.setListener(null);</div><div class="line">                    clear(view);</div><div class="line">                    dispatchRemoveFinished(holder);</div><div class="line">                    mRemoveAnimations.remove(holder);</div><div class="line">                    dispatchFinishedWhenDone();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">    animation.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void animateAddImpl(final RecyclerView.ViewHolder holder) &#123;</div><div class="line">    mAddAnimations.add(holder);</div><div class="line">    final ViewPropertyAnimatorCompat animation = getAddAnimator(holder);</div><div class="line">    animation.setDuration(getAddDuration()).</div><div class="line">            setListener(new VpaListenerAdapter() &#123;</div><div class="line">                @Override</div><div class="line">                public void onAnimationStart(View view) &#123;</div><div class="line">                    ViewCompat.setAlpha(view,1);</div><div class="line">                    dispatchAddStarting(holder);</div><div class="line">                &#125;</div><div class="line">                @Override</div><div class="line">                public void onAnimationCancel(View view) &#123;</div><div class="line">                    clear(view);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onAnimationEnd(View view) &#123;</div><div class="line">                    animation.setListener(null);</div><div class="line">                    dispatchAddFinished(holder);</div><div class="line">                    mAddAnimations.remove(holder);</div><div class="line">                    dispatchFinishedWhenDone();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected abstract ViewPropertyAnimatorCompat getAddAnimator(RecyclerView.ViewHolder viewHolder);</div><div class="line">protected abstract ViewPropertyAnimatorCompat getRemoveAnimator(RecyclerView.ViewHolder viewHolder);</div><div class="line"></div><div class="line">public void clear(View v) &#123;</div><div class="line">    ViewCompat.setAlpha(v, 1);</div><div class="line">    ViewCompat.setScaleY(v, 1);</div><div class="line">    ViewCompat.setScaleX(v, 1);</div><div class="line">    ViewCompat.setTranslationY(v, 0);</div><div class="line">    ViewCompat.setTranslationX(v, 0);</div><div class="line">    ViewCompat.setRotation(v, 0);</div><div class="line">    ViewCompat.setRotationY(v, 0);</div><div class="line">    ViewCompat.setRotationX(v, 0);</div><div class="line">    ViewCompat.setPivotY(v, v.getMeasuredHeight() / 2);</div><div class="line">    ViewCompat.setPivotX(v, v.getMeasuredWidth() / 2);</div><div class="line">    ViewCompat.animate(v).setInterpolator(null).setStartDelay(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们就可以继承BaseItemAnimator类实现自己的动画效果，下面给出一个示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected ViewPropertyAnimatorCompat getAddAnimator(RecyclerView.ViewHolder item) &#123;</div><div class="line">    ViewCompat.setTranslationX(item.itemView, -item.itemView.getWidth());</div><div class="line">    return ViewCompat.animate(item.itemView).translationX(0);</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">protected ViewPropertyAnimatorCompat getRemoveAnimator(RecyclerView.ViewHolder item) &#123;</div><div class="line">    return ViewCompat.animate(item.itemView).translationX(item.itemView.getWidth());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>详细代码见<a href="https://github.com/pandavickey/CustomFeature-RecyclerView" target="_blank" rel="external">github</a></p>
<h1 id="自定义ItemDecoration"><a href="#自定义ItemDecoration" class="headerlink" title="自定义ItemDecoration"></a>自定义ItemDecoration</h1><p>自定义ItemDecoration需要继承RecyclerView.ItemDecoration抽象类，源码很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public static abstract class ItemDecoration &#123;</div><div class="line">    public void onDraw(Canvas c, RecyclerView parent, State state) &#123;</div><div class="line">        onDraw(c, parent);</div><div class="line">    &#125;</div><div class="line">    @Deprecated</div><div class="line">    public void onDraw(Canvas c, RecyclerView parent) &#123;</div><div class="line">    &#125;</div><div class="line">    public void onDrawOver(Canvas c, RecyclerView parent, State state) &#123;</div><div class="line">        onDrawOver(c, parent);</div><div class="line">    &#125;</div><div class="line">    @Deprecated</div><div class="line">    public void onDrawOver(Canvas c, RecyclerView parent) &#123;</div><div class="line">    &#125;</div><div class="line">    @Deprecated</div><div class="line">    public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123;</div><div class="line">        outRect.set(0, 0, 0, 0);</div><div class="line">    &#125;</div><div class="line">    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123;</div><div class="line">        getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(),</div><div class="line">                parent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>官方推荐使用含有state参数的方法，所以主要就是重载三个方法：</p>
<ul>
<li>onDraw(Canvas c, RecyclerView parent, State state)</li>
<li>onDrawOver(Canvas c, RecyclerView parent, State state)</li>
<li>getItemOffsets(Rect outRect, View view, RecyclerView parent, State state)</li>
</ul>
<p>onDraw用于绘制divider，它是绘制在item下面的，所以中间部分会被item遮挡住；<br>onDrawOver绘制在item上面，所以不受位置的限制；<br>getItemOffsets实际上就是给每个item一个padding，实现item之间的间隙。</p>
<p>实际业务中我们经常会遇到这样的需求，一个可选择的gridview，选中与否有不同的边框，效果图如下：</p>
<p><img src="/img/设计图.png" alt="设计图"></p>
<p>以我有限的界面开发经验，不管如何控制，要实现每个分割线都是相同的宽度，选中界面的边框正好压盖周围的边框还是很有难度的，看到recyclerview的自定义ItemDecoration才终于发现一道曙光。</p>
<p>我的做法是在getItemOffsets函数中，我判断一个item上下左右是否有临近的item，没有的话给两倍的dividerwidth，否则一倍的dividerwidth，这样就能控制所有的item四周都是有同样宽度的间隙。然后在onDrawOver中实现每个item分割线的绘制，同时判断是否选中，再绘制选中的边框，整体效果如下：</p>
<p><img src="/img/效果图.png" alt="效果图"></p>
<p>还是完美的实现了UI妹子要求的效果(^_^)。</p>
<p>详细代码见<a href="https://github.com/pandavickey/CustomFeature-RecyclerView" target="_blank" rel="external">github</a></p>
<h1 id="自定义LayoutManager"><a href="#自定义LayoutManager" class="headerlink" title="自定义LayoutManager"></a>自定义LayoutManager</h1><p>LayoutManager可以说是整个RecyclerView的精髓，整个RecyclerView的Recycler也是在LayoutManager做的，官方目前提供了LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager三种LayoutManager，分别使用在线性、方格以及不规则瀑布流的场景，基本上实现了日常的大部分需求。目前精力有限，后续再做分解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/29/RecyclerView高端定制三部曲/" data-id="cito0mhjh00049ctopywe9n9a" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Dagger2从入门到会用再到暂时放弃" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/29/Dagger2从入门到会用再到暂时放弃/" class="article-date">
  <time datetime="2016-09-29T07:06:07.000Z" itemprop="datePublished">2016-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/29/Dagger2从入门到会用再到暂时放弃/">Dagger2从入门到会用再到暂时放弃</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Dagger2是一种依赖注入框架，目前由Google维护。说到依赖注入，标准定义是目标类中所依赖的其他的类的初始化过程，不是通过手动编码的方式创建，而是通过技术手段可以把其他的类的已经初始化好的实例自动注入到目标类中。说简单就是一次构建，到处注入。目前只能理解这个定义，具体的应用场景坑还没踩够，还不能意会。</p>
<p>这两天也看了不少Dagger2的Blog,大部分都翻译自<a href="http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/" target="_blank" rel="external">tasting-dagger-2-on-android</a> 这篇文章再修修改改，参考的工程主要是<a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="external">Android-CleanArchitecture</a> 关于Clean框架用Dagger实现以及<a href="https://github.com/google/dagger" target="_blank" rel="external">官方</a>咖啡机的故事。主要实现的代码总结起来是以下几行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Hello &#123;</div><div class="line">    @Inject Hello() &#123;  //Inject注解构造函数</div><div class="line">    &#125;</div><div class="line">    public void say() &#123;</div><div class="line">        System.out.println(“hello world”);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Component  //Component组件绑定宿主</div><div class="line">public interface HelloComponent &#123;</div><div class="line">    void inject(HelloDagger dagger);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class HelloDagger &#123;</div><div class="line">    @Inject</div><div class="line">    static Hello hello;//声明注入依赖</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        DaggerHelloComponent.create().inject(new HelloDagger());//Dagger默认生成DaggerHelloComponent类，调用inject方法注入对象</div><div class="line">        hello.say();  //对象已经初始化了</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是最简单的一个Dagger2的实例，当然Hello类是无参的构造函数，如果有参构造的话还需要引入module和provides两个注解，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Hello &#123;</div><div class="line">    private String hello;</div><div class="line">    @Inject Hello(String hello) &#123;  //有参构造函数</div><div class="line">        this.hello = hello;</div><div class="line">    &#125;</div><div class="line">    public void say() &#123;</div><div class="line">        System.out.println(hello);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Module</div><div class="line">public class HelloModule &#123;</div><div class="line">    String hello = &quot;hello&quot;;</div><div class="line">    public HelloModule(String hello) &#123;</div><div class="line">        this.hello = hello;</div><div class="line">    &#125;</div><div class="line">    @Provides Hello getHello()&#123;  //Provides注解返回依赖的对象</div><div class="line">        return new Hello(hello);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Component(modules = HelloModule.class)  //绑定依赖对象和宿主</div><div class="line">public interface HelloComponent &#123;</div><div class="line">    void inject(HelloDagger dagger);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class HelloDagger &#123;</div><div class="line">    @Inject</div><div class="line">    static Hello hello;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        DaggerHelloComponent.builder()</div><div class="line">                .helloModule(new HelloModule(&quot;hello world&quot;))  //创建module对象</div><div class="line">                .build()</div><div class="line">                .inject(new HelloDagger());//注入</div><div class="line">        hello.say();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比较常用的就是@Inject、@Module、@Provides以及@Component注解，inject在宿主中声明依赖对象，module和provides配合初始化依赖对象，component连接彼此，完成注入过程。整个过程就是一个A a = new A()的过程，只是彼此分离，还是一个解耦的目的。</p>
<p>在构建代码的过程中我们可能还感受不到依赖注入的好处，当程序在膨胀，业务不断累积的过程中，我们发现我们很难遵守面向对象六大原则之依赖倒置原则。如果我们使用了Dagger，当依赖对象发生改变时，我们的Inject和component模块都不需要改变，只需要改变module模块，而这一模块相对独立，变动起来真的随心所欲。</p>
<p>Dagger2终归还是一个模块解耦的利器，坑还没踩够，所以体会不到真正的好处，只能暂时放弃了。就像Fernando Cejas说的，Dagger2的好处主要有三点：</p>
<ul>
<li>Since dependencies can be injected and configured externally we can reuse those components.</li>
<li>When injecting abstractions as collaborators, we can just change the implementation of any object without having to make a lot of changes in our codebase, since that object instantiation resides in one place isolated and decoupled.</li>
<li>Dependencies can be injected into a component: it is possible to inject mock implementations of these dependencies which makes testing easier.</li>
</ul>
<p>最后大神镇楼<br><img src="/img/Fernando Cejas.png" alt="Fernando Cejas.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/29/Dagger2从入门到会用再到暂时放弃/" data-id="cito0mhjc00019ctos5ubdf54" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Fresco源码浅析-ImagePipeline模块（三）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/29/Fresco源码浅析-ImagePipeline模块（三）/" class="article-date">
  <time datetime="2016-09-29T07:02:07.000Z" itemprop="datePublished">2016-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/29/Fresco源码浅析-ImagePipeline模块（三）/">Fresco源码浅析-ImagePipeline模块（三）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ImagePipeline是Fresco读取数据的整个调度系统，作为一个图片加载组件，主要工作流程为：</p>
<ul>
<li>检查内存缓存</li>
<li>检查磁盘缓存</li>
<li>文件读取或网络请求，并存储到各个缓存。<br>官方流程图如下：<br><img src="/img/imagepipeline.png" alt="imagepipeline.png"></li>
</ul>
<p>这和主要的图片加载逻辑基本类似，既然如此，那我们就从图片加载组件最主要的两个方面入手分析源码：<br>1） 如何自定义缓存线程和加载线程的配置；<br>2） 缓存设计算法。</p>
<p>首先看第一个问题，要看ImagePipeline的配置，我们来分析一下ImagePipelineConfig的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@Nullable private final AnimatedImageFactory mAnimatedImageFactory;</div><div class="line">private final Bitmap.Config mBitmapConfig;</div><div class="line">private final Supplier&lt;MemoryCacheParams&gt; mBitmapMemoryCacheParamsSupplier; //内存缓存数据的策略</div><div class="line">private final CacheKeyFactory mCacheKeyFactory; //缓存键值对的获取</div><div class="line">private final Context mContext;</div><div class="line">private final boolean mDownsampleEnabled;</div><div class="line">private final boolean mDecodeMemoryFileEnabled;</div><div class="line">private final FileCacheFactory mFileCacheFactory; // 文件缓存键值对</div><div class="line">private final Supplier&lt;MemoryCacheParams&gt; mEncodedMemoryCacheParamsSupplier;  //原码内存缓存参数</div><div class="line">private final ExecutorSupplier mExecutorSupplier;  //获取线程池</div><div class="line">private final ImageCacheStatsTracker mImageCacheStatsTracker;//Cache埋点工具</div><div class="line">@Nullable private final ImageDecoder mImageDecoder; //解码器</div><div class="line">private final Supplier&lt;Boolean&gt; mIsPrefetchEnabledSupplier;</div><div class="line">private final DiskCacheConfig mMainDiskCacheConfig;//磁盘缓存配置</div><div class="line">private final MemoryTrimmableRegistry mMemoryTrimmableRegistry;</div><div class="line">private final NetworkFetcher mNetworkFetcher; //网络获取器</div><div class="line">@Nullable private final PlatformBitmapFactory mPlatformBitmapFactory;</div><div class="line">private final PoolFactory mPoolFactory;</div><div class="line">private final ProgressiveJpegConfig mProgressiveJpegConfig;  //渐进图片配置</div><div class="line">private final Set&lt;RequestListener&gt; mRequestListeners;</div><div class="line">private final boolean mResizeAndRotateEnabledForNetwork;</div><div class="line">private final DiskCacheConfig mSmallImageDiskCacheConfig;//小图缓存配置</div><div class="line">private final ImagePipelineExperiments mImagePipelineExperiments;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>ImagePipeline的可配置项如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ImagePipelineConfig config = ImagePipelineConfig.newBuilder()</div><div class="line">    .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier)  //bitmap缓存配置</div><div class="line">    .setCacheKeyFactory(cacheKeyFactory) //设置缓存键值对</div><div class="line">    .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier)//设置原码内存缓存配置</div><div class="line">    .setExecutorSupplier(executorSupplier) //各种线程池</div><div class="line">    .setImageCacheStatsTracker(imageCacheStatsTracker)//缓存打点</div><div class="line">    .setMainDiskCacheConfig(mainDiskCacheConfig) //主磁盘缓存</div><div class="line">    .setMemoryTrimmableRegistry(memoryTrimmableRegistry) </div><div class="line">    .setNetworkFetchProducer(networkFetchProducer)//网络请求配置</div><div class="line">    .setPoolFactory(poolFactory)</div><div class="line">    .setProgressiveJpegConfig(progressiveJpegConfig)//渐进图片配置</div><div class="line">    .setRequestListeners(requestListeners)//请求监听</div><div class="line">    .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig)//小图缓存</div><div class="line">    .build();</div><div class="line">Fresco.initialize(context, config);</div></pre></td></tr></table></figure></p>
<p>ImagePipeline用到了三个缓存，首先是DiskCache，然后还有两个MemoryCache，分别是保存已解码Bitmap的和保存EncodedImage的缓存。Fresco将未解码的原始数据也进行了内存缓存，然后根据是否旋转或者缩放以及解码质量进行解码成bitmap存放内存空间，其实在我所接触的应用场景中这部分内容其实是不太需要的，因为一张图片基本上只在一个地方使用，即使多处使用也不太需要这么复杂的变换，可能Fresco想的比较周到吧。<br>内存缓存使用的是通用的lru算法（最近最少使用原则），内存缓存的设计代码在CountingMemoryCache，CountingMemoryCache是一个基于LRU策略来管理缓存中元素的一个类，它实现的trim()方法可以根据Type的不同来采取不同策略的回收为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Layer of memory cache stack responsible for managing eviction of the the cached items.</div><div class="line"> *</div><div class="line"> * &lt;p&gt; This layer is responsible for LRU eviction strategy and for maintaining the size boundaries</div><div class="line"> * of the cached items.</div><div class="line"> *</div><div class="line"> * &lt;p&gt; Only the exclusively owned elements, i.e. the elements not referenced by any client, can be</div><div class="line"> * evicted.</div><div class="line"> *</div><div class="line"> * @param &lt;K&gt; the key type</div><div class="line"> * @param &lt;V&gt; the value type</div><div class="line"> */</div><div class="line">@ThreadSafe</div><div class="line">public class CountingMemoryCache&lt;K, V&gt; implements MemoryCache&lt;K, V&gt;, MemoryTrimmable &#123;</div><div class="line">   ...//省略代码</div><div class="line">    /** Trims the cache according to the specified trimming strategy and the given trim type. */</div><div class="line">  @Override</div><div class="line">  public void trim(MemoryTrimType trimType) &#123;</div><div class="line">    ArrayList&lt;Entry&lt;K, V&gt;&gt; oldEntries;</div><div class="line">    final double trimRatio = mCacheTrimStrategy.getTrimRatio(trimType);</div><div class="line">    synchronized (this) &#123;</div><div class="line">      int targetCacheSize = (int) (mCachedEntries.getSizeInBytes() * (1 - trimRatio));</div><div class="line">      int targetEvictionQueueSize = Math.max(0, targetCacheSize - getInUseSizeInBytes());</div><div class="line">      oldEntries = trimExclusivelyOwnedEntries(Integer.MAX_VALUE, targetEvictionQueueSize);</div><div class="line">      makeOrphans(oldEntries);</div><div class="line">    &#125;</div><div class="line">    maybeClose(oldEntries);</div><div class="line">    maybeNotifyExclusiveEntryRemoval(oldEntries);</div><div class="line">    maybeUpdateCacheParams();</div><div class="line">    maybeEvictEntries();</div><div class="line">  &#125;</div><div class="line">  ...//省略代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Fresco使用的黑科技还有很多，它是一份巨大的宝藏等着挖掘，我只是粗浅的总结了部分我get到的点，以后进一步深入学习中再和大家分享。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/29/Fresco源码浅析-ImagePipeline模块（三）/" data-id="cito0mhje00029ctokn4ieru4" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Fresco源码浅析-Drawee模块（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/29/Fresco源码浅析-Drawee模块（二）/" class="article-date">
  <time datetime="2016-09-29T07:01:07.000Z" itemprop="datePublished">2016-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/29/Fresco源码浅析-Drawee模块（二）/">Fresco源码浅析-Drawee模块（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Drawee模块负责图片的展示，主要涉及到的概念包括DraweeView（V）、DraweeHierarchy(M)、DraweeController(C),这是一个典型的MVC的结构。</p>
<h1 id="DraweeView（V）"><a href="#DraweeView（V）" class="headerlink" title="DraweeView（V）"></a>DraweeView（V）</h1><p>使用Fresco的时候，我们首先直接使用SimpleDraweeView这个官方自定义的控件，它的继承结构是这样的：<br><img src="/img/SimpleDraweeView类继承关系.png" alt="SimpleDraweeView类继承关系.png"></p>
<p>SimpleDraweeView主要实现了setImageURI方法，设置了一个controller。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void setImageURI(Uri uri, @Nullable Object callerContext) &#123;</div><div class="line">  DraweeController controller = mSimpleDraweeControllerBuilder</div><div class="line">      .setCallerContext(callerContext)</div><div class="line">      .setUri(uri)</div><div class="line">      .setOldController(getController())</div><div class="line">      .build();</div><div class="line">  setController(controller);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>GenericDraweeView继承自DraweeView，实现了一个GenericDraweeHierarchy的泛型。Fresco支持高度定制，你可以通过重写DraweeHierarchy定制自己的数据处理。<br>DraweeView控制图片展示的核心业务逻辑，控件初始化的时候初始化了一个DraweeHolder帮助类，并将得到的Hierarchy以及Controller交给DraweeHolder处理。</p>
<h1 id="DraweeHierarchy-M"><a href="#DraweeHierarchy-M" class="headerlink" title="DraweeHierarchy(M)"></a>DraweeHierarchy(M)</h1><p>Fresco实现了各种数据处理场景下界面的展示，包括：</p>
<ul>
<li>占位图</li>
<li>自身图片</li>
<li>进度</li>
<li>错误图</li>
<li>重试</li>
<li>…<br>DraweeHierarchy作为model主要组织这些数据。GenericDraweeHierarchy实现了一个默认的DraweeHierarchy，因为展示的图片数据都是Drawable，针对这些场景，DraweeHierarchy实现了一个FadeDrawable类，继承自ArrayDrawable，从名字可以看出这是一个层级的Drawable，然后通过Fade某一层Alpha值，控制显示。成员变量如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private final RootDrawable mTopLevelDrawable; //Imageview最终绘制需要的Drawable。</div><div class="line">private final FadeDrawable mFadeDrawable; //所有数据整合后存放的ArrayDrawable。</div><div class="line">private final ForwardingDrawable mActualImageWrapper;  //加载成功展示的图片</div><div class="line">private final int mPlaceholderImageIndex;//占位图index</div><div class="line">private final int mProgressBarImageIndex;//进度条index</div><div class="line">private final int mActualImageIndex;//图片index</div><div class="line">private final int mRetryImageIndex;//重新加载index</div><div class="line">private final int mFailureImageIndex;//失败图index</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在DraweeHierarchy构造的时候填充mFadeDrawable：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">mActualImageWrapper = new ForwardingDrawable(mEmptyActualImageDrawable);</div><div class="line"></div><div class="line">int numBackgrounds = (builder.getBackgrounds() != null) ? builder.getBackgrounds().size() : 0;</div><div class="line">int numOverlays = (builder.getOverlays() != null) ? builder.getOverlays().size() : 0;</div><div class="line">numOverlays += (builder.getPressedStateOverlay() != null) ? 1 : 0;</div><div class="line"></div><div class="line">// layer indices and count</div><div class="line">int numLayers = 0;</div><div class="line">int backgroundsIndex = numLayers;</div><div class="line">numLayers += numBackgrounds;</div><div class="line">mPlaceholderImageIndex = numLayers++;</div><div class="line">mActualImageIndex = numLayers++;</div><div class="line">mProgressBarImageIndex = numLayers++;</div><div class="line">mRetryImageIndex = numLayers++;</div><div class="line">mFailureImageIndex = numLayers++;</div><div class="line">int overlaysIndex = numLayers;</div><div class="line">numLayers += numOverlays;</div><div class="line"></div><div class="line">// array of layers</div><div class="line">Drawable[] layers = new Drawable[numLayers];</div><div class="line">if (numBackgrounds &gt; 0) &#123;</div><div class="line">  int index = 0;</div><div class="line">  for (Drawable background : builder.getBackgrounds()) &#123;</div><div class="line">    layers[backgroundsIndex + index++] = buildBranch(background, null);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">layers[mPlaceholderImageIndex] = buildBranch(</div><div class="line">    builder.getPlaceholderImage(),</div><div class="line">    builder.getPlaceholderImageScaleType());</div><div class="line">layers[mActualImageIndex] = buildActualImageBranch(</div><div class="line">    mActualImageWrapper,</div><div class="line">    builder.getActualImageScaleType(),</div><div class="line">    builder.getActualImageFocusPoint(),</div><div class="line">    builder.getActualImageMatrix(),</div><div class="line">    builder.getActualImageColorFilter());</div><div class="line">layers[mProgressBarImageIndex] = buildBranch(</div><div class="line">    builder.getProgressBarImage(),</div><div class="line">    builder.getProgressBarImageScaleType());</div><div class="line">layers[mRetryImageIndex] = buildBranch(</div><div class="line">    builder.getRetryImage(),</div><div class="line">    builder.getRetryImageScaleType());</div><div class="line">layers[mFailureImageIndex] = buildBranch(</div><div class="line">    builder.getFailureImage(),</div><div class="line">    builder.getFailureImageScaleType());</div><div class="line">if (numOverlays &gt; 0) &#123;</div><div class="line">  int index = 0;</div><div class="line">  if (builder.getOverlays() != null) &#123;</div><div class="line">    for (Drawable overlay : builder.getOverlays()) &#123;</div><div class="line">      layers[overlaysIndex + index++] = buildBranch(overlay, null);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  if (builder.getPressedStateOverlay() != null) &#123;</div><div class="line">    layers[overlaysIndex + index] = buildBranch(builder.getPressedStateOverlay(), null);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DraweeHierarchy 对于属性的设置利用了构造者模式，定义了一个GenericDraweeHierarchyBuilder。GenericDraweeHierarchyBuilder可以直接在代码里初始化，也可以读取XML的配置信息。</p>
<h1 id="DraweeController-C"><a href="#DraweeController-C" class="headerlink" title="DraweeController(C)"></a>DraweeController(C)</h1><p>DraweeController的功能包括：</p>
<ul>
<li><h6 id="发起数据请求，得到请求结果，刷新界面；"><a href="#发起数据请求，得到请求结果，刷新界面；" class="headerlink" title="发起数据请求，得到请求结果，刷新界面；"></a>发起数据请求，得到请求结果，刷新界面；</h6></li>
<li><h6 id="针对界面行为事件控制数据流的处理逻辑。"><a href="#针对界面行为事件控制数据流的处理逻辑。" class="headerlink" title="针对界面行为事件控制数据流的处理逻辑。"></a>针对界面行为事件控制数据流的处理逻辑。</h6>controller 的类结构：<br>DraweeController<br>–| AbstractDraweeController<br>—-| PipelineDraweeController</li>
</ul>
<p>在纷繁的代码中追踪数据加载的逻辑确实好头疼，我发现单纯的从drawee来查看数据的加载过程还是太复杂，我将在imagepipeline模块整理完之后再回头整理drawee与image pipeline的交互过程，今天我们只是简单的看一下流程。<br>我们只能从最开始的view初始化看起，DraweeView的onAttachedToWindow函数中调用了attachController方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private void attachController() &#123;</div><div class="line">  if (mIsControllerAttached) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);</div><div class="line">  mIsControllerAttached = true;</div><div class="line">  if (mController != null &amp;&amp;</div><div class="line">      mController.getHierarchy() != null) &#123;</div><div class="line">    mController.onAttach();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里就是view调用controller数据加载的入口。controller的onAttach方法又做了什么呢：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onAttach() &#123;</div><div class="line">  mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER);</div><div class="line">  Preconditions.checkNotNull(mSettableDraweeHierarchy);</div><div class="line">  mDeferredReleaser.cancelDeferredRelease(this);</div><div class="line">  mIsAttached = true;</div><div class="line">  if (!mIsRequestSubmitted) &#123;</div><div class="line">    submitRequest(); //发起请求</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看字面含义我们已经猜到，他在最后发起了数据的请求，我们再看看这个请求是怎么做的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">protected void submitRequest() &#123;</div><div class="line">  ...........//省略代码</div><div class="line">  mDataSource = getDataSource();</div><div class="line"> ...........//省略代码</div><div class="line">  final DataSubscriber&lt;T&gt; dataSubscriber =</div><div class="line">      new BaseDataSubscriber&lt;T&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public void onNewResultImpl(DataSource&lt;T&gt; dataSource) &#123;</div><div class="line">          ..............//获取图片成功</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onFailureImpl(DataSource&lt;T&gt; dataSource) &#123;</div><div class="line">          ...............//获取图片失败</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onProgressUpdate(DataSource&lt;T&gt; dataSource) &#123;</div><div class="line">          ..............//图片获取过程中</div><div class="line">        &#125;</div><div class="line">      &#125;;</div><div class="line">  mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到这里利用了观察者的设计模式，得到了一个数据流，并向这个数据流注册了一个观察者。getDataSource是个虚方法，真正的实现在PipelineDraweeController和VolleyDraweeController中，默认调用Fresco的initialize方法，创建的是PipelineDraweeController，他的getDataSource实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDataSource() &#123;</div><div class="line">  return mDataSourceSupplier.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Supplier的用法我还是第一次看到，他有一个官方的名字叫做“惰性求值”，我们传递Supplier对象，直到调用get方法时，运算才会执行。我们查看get方法的重载在AbstractDraweeControllerBuilder看到了这样一块代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">protected Supplier&lt;DataSource&lt;IMAGE&gt;&gt; getDataSourceSupplierForRequest(</div><div class="line">    final REQUEST imageRequest,</div><div class="line">    final boolean bitmapCacheOnly) &#123;</div><div class="line">  final Object callerContext = getCallerContext();</div><div class="line">  return new Supplier&lt;DataSource&lt;IMAGE&gt;&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public DataSource&lt;IMAGE&gt; get() &#123;</div><div class="line">      return getDataSourceForRequest(imageRequest, callerContext, bitmapCacheOnly);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">      return Objects.toStringHelper(this)</div><div class="line">          .add(&quot;request&quot;, imageRequest.toString())</div><div class="line">          .toString();</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>没错，就是getDataSourceForRequest实现了数据的加载，我们在PipelineDraweeControllerBuilder中看到了具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDataSourceForRequest(</div><div class="line">    ImageRequest imageRequest,</div><div class="line">    Object callerContext,</div><div class="line">    boolean bitmapCacheOnly) &#123;</div><div class="line">  if (bitmapCacheOnly) &#123;</div><div class="line">    return mImagePipeline.fetchImageFromBitmapCache(imageRequest, callerContext);</div><div class="line">  &#125; else &#123;</div><div class="line">    return mImagePipeline.fetchDecodedImage(imageRequest, callerContext);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此我们终于调用了ImagePipeline的fetch方法，实现了数据的请求，我们回过头来总结一下这个流程：<br>ImageView在setImageUri的过程过程中创建了一个controller，controller的创建基于builder模式，最后调用build函数，接下来的函数链是：buildController  -&gt; obtainController -&gt; obtainDataSourceSupplier -&gt; getDataSourceSupplierForRequest完成了整个controller的创建，接下来在View的onAttachedToWindow调用controller中依次调用 onAttach -&gt; submitRequest -&gt; getDataSource 然后执行get中的请求操作。</p>
<p>Controller中同时定义了一个GestureDetector，用于对View事件的拦截，我看到主要还是在onClick事件中处理是否重新加载。</p>
<p>至此整个图片展示的部分我们已经大致的梳理了一遍，核心还是在于model的处理，ImageView设置了一个drawable之后，control直接控制这个drawable，利用drawable的invalidateSelf函数直接刷新View，MVC模式中model是可以操作View的，这也真是MVC与MVP模式的最大区别。controller的逻辑比较简单，就是先初始化构建，然后View显示的时候执行他的数据请求操作，但是代码比较复杂，梳理起来比较麻烦，还好在梳理的过程中看到了很多优秀的设计。</p>
<h1 id="下一页-ImagePipeline介绍"><a href="#下一页-ImagePipeline介绍" class="headerlink" title="下一页 ImagePipeline介绍"></a><a href="http://www.jianshu.com/p/116639f920b6" target="_blank" rel="external">下一页 ImagePipeline介绍</a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/29/Fresco源码浅析-Drawee模块（二）/" data-id="cito0mhjg00039ctounh2l0np" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Fresco源码浅析-序（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/29/Fresco源码浅析-序（一）/" class="article-date">
  <time datetime="2016-09-29T07:00:07.000Z" itemprop="datePublished">2016-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/29/Fresco源码浅析-序（一）/">Fresco源码浅析-序（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>大名鼎鼎的Fresco开源一年多了，已经有越来越多的尝鲜者开始使用。目前我们的项目对于图片的加载没有过多的需求，但对于Fresco还是充满了好。我接下来几篇博文讲围绕着他的架构设计、图片处理、缓存设计、线程管理等议题深入源码，尽可能的给出自己的一些理解。（水平有限，第一次尝试写博客，有不对的地方欢迎指正）</p>
<h1 id="Fresco优势"><a href="#Fresco优势" class="headerlink" title="Fresco优势"></a>Fresco优势</h1><ul>
<li><h6 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h6>bitmap是Android中内存占用的大块头，Fresco用了一个略显“流氓”的方案，将bitmap存储在共享内存区域，这样就不会计算在app分配的堆内存大小了，有效的减少了OOM，但这毕竟是钻了Android的一个空子，5.0以上的版本他及时更改了过来。不过这也可以作为一种思路，学习一下如何高效利用共享内存，以备我们随时“流氓”一下^_^</li>
<li><h6 id="支持更多的图片格式"><a href="#支持更多的图片格式" class="headerlink" title="支持更多的图片格式"></a>支持更多的图片格式</h6>Fresco支持本地图片和网络图片，支持GIF和WebP格式的图片，</li>
<li><h6 id="渐进式图片加载"><a href="#渐进式图片加载" class="headerlink" title="渐进式图片加载"></a>渐进式图片加载</h6>渐进式图片能带来更好的用户体验，Fresco支持这个格式，而且使用的时候只需要像普通图片一样提供Url即可，不过这还需要后端哥哥们的配合。。。</li>
<li><h6 id="封装了各种场景下的图片展示"><a href="#封装了各种场景下的图片展示" class="headerlink" title="封装了各种场景下的图片展示"></a>封装了各种场景下的图片展示</h6><p>圆角，自定义居中，占位图，错误图，loading图，再次加载图，你能想到的场景Fresco都帮你想到了，使用起来及其方便。</p>
<h1 id="源码分析要点"><a href="#源码分析要点" class="headerlink" title="源码分析要点"></a>源码分析要点</h1><p>github上down下来的Fresco代码结构是这样的：<br><img src="/img/Fresco官方代码结构.png" alt="Fresco官方代码结构.png"><br>看到这么多module是不是有点爆炸的感觉，反正我第一眼是炸了。。<br>然后我在另外一个工程引入了一下Fresco包，给我下载的代码结构是这样的：<br><img src="/img/Fresco引入包代码结构.png" alt="Fresco引入包代码结构.png"><br>对比看起来就比较清晰了，主要是Facebook的core包，drawee和imagepipeline。core包是Facebook的基础包，这里面有很多工具类可以借用，drawee主要是用来图片的展示，imagepipeline则设计了一个图片加载框架，接下来讲主要围绕这两块深入到Fresco的源码中去（一直在尝试深入，其实只是在门口游荡，惭愧）。</p>
</li>
<li><p><a href="http://www.jianshu.com/p/edc36431fede" target="_blank" rel="external"> drawee</a></p>
</li>
<li><a href="http://www.jianshu.com/p/116639f920b6" target="_blank" rel="external">imagepipeline</a></li>
</ul>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>Fresco使用起来特别简单，如果你是已经在代码中使用了大量网络图片，那改动可能会有点大，因为view需要改用Fresco默认提供的一个叫SimpleDraweeView的ImageView，这要涉及到xml和Java代码的改动。不过使用起来确实超级方便，直接调用setimageuri方法就完事了，更多的关于初始化设置占位图、错误图、loading图、重复加载图详见官方说明，这里不再赘述了（有时间我准备改造一下Fresco的使用方式，还是用我们熟悉的传入ImageView和Uri的方式，这样集成和替换图片加载库的代价就会很低，如果觉得有价值请顶我，让我更有动力）。</p>
<h1 id="文献引用"><a href="#文献引用" class="headerlink" title="文献引用"></a>文献引用</h1><blockquote>
<p><a href="http://www.fresco-cn.org" target="_blank" rel="external">Fresco 中文文档</a><br><a href="http://www.cnblogs.com/pandapan/p/4634454.html" target="_blank" rel="external">Fresco 源码解析</a></p>
</blockquote>
<h1 id="下一页-Drawee模块介绍"><a href="#下一页-Drawee模块介绍" class="headerlink" title="下一页 Drawee模块介绍"></a><a href="http://www.jianshu.com/p/edc36431fede" target="_blank" rel="external">下一页 Drawee模块介绍</a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/29/Fresco源码浅析-序（一）/" data-id="cito0mhjj00059cto8gcz3wjr" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/29/Android-主要的热修复方案原理分析/">Android 主要的热修复方案原理分析</a>
          </li>
        
          <li>
            <a href="/2016/09/29/RecyclerView高端定制三部曲/">RecyclerView高端定制三部曲</a>
          </li>
        
          <li>
            <a href="/2016/09/29/Dagger2从入门到会用再到暂时放弃/">Dagger2从入门到会用再到暂时放弃</a>
          </li>
        
          <li>
            <a href="/2016/09/29/Fresco源码浅析-ImagePipeline模块（三）/">Fresco源码浅析-ImagePipeline模块（三）</a>
          </li>
        
          <li>
            <a href="/2016/09/29/Fresco源码浅析-Drawee模块（二）/">Fresco源码浅析-Drawee模块（二）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>